# Заметки про виртуальные таблицы во время множественного наследования в компиляторе GCC C++-4.0.1

## Основы. Простое наследование

Как мы обсуждали в классе, простое наследование приводит к построению объекта с данными базового класса, располагающимися перед данными класса-наследника. Итак, если классы `A` и `B` опеделены таким образом:

    class A {
    public:
      int a;
    };
    
    class B : public A {
    public:
      int b;
    };

то объекты типа `B` будут располагаться в памяти примерно так (где `b` является указателем на соответствующий объект):

    b --> +-----------+
          |     x     |
          +-----------+
          |     y     |
          +-----------+

Если у вас есть виртуальные методы:

    class A {
    public:
      int a;
      virtual void v();
    };
    
    class B : public A {
    public:
      int b;
    };

то вы получаете ещё и виртуальную таблицу:

                               +-----------------------+
                               |     0 (top_offset)    |
                               +-----------------------+
    b --> +----------+         | ptr to typeinfo for B |
          |  vtable  |-------> +-----------------------+
          +----------+         |         A::v()        |
          |     x    |         +-----------------------+
          +----------+
          |     y    
    1000
    |
          +----------+

такую, что `top_offset` и указатель на `typeinfo` находятся поверх того места, куда ведут указатели на *vtable*.

## Простое множественное наследование

Теперь рассмотрим множественное наследование:

    class A {
    public:
      int a;
      virtual void v();
    };
    
    class B {
    public:
      int b;
      virtual void w();
    };
    
    class C : public A, public B {
    public:
      int c;
    };

В этом случае объекты типа `C` имеют следующее построение:

                               +-----------------------+
                               |     0 (top_offset)    |
                               +-----------------------+
    c --> +----------+         | ptr to typeinfo for C |
          |  vtable  |-------> +-----------------------+
          +----------+         |         A::v()        |
          |     a    |         +-----------------------+
          +----------+         |    -8 (top_offset)    |
          |  vtable  |---+     +-----------------------+
          +----------+   |     | ptr to typeinfo for C |
          |     b    |   +---> +-----------------------+
          +----------+         |         B::w()        |
          |     c    |         +-----------------------+
          +----------+

...*но почему*? Почему две виртуальные таблицы в одной? Что ж, подумаем о подмене типов. Если у меня есть указатель на `C`, я могу передать его в функцию, которая ожидает указатель на `A` или в функцию, ожидающую уазатель на `B`. Если функция ожидает указатель на `A` и я хочу передать ей значение моей переменной `c` (являющейся указателем на `C`), у меня уже всё готово. Вызов `A::v()` может быть сделан через (первую) *vtable*, а вызываемая функция имеет доступ к члену `a` через указатель, который я передаю таким же образом как и *любой* указатель на `A`.

Тем не менее, если я передаю значение моей переменной с указателем `c` в функцию, которая ожидает указатель на `B`, нам *так же* нужен вложенный объект типа `B` в `C` чтобы на него ссылаться. Поэтому у нас есть второй указатель на *vtable*. Мы можем передать значение указателя (`c` + 8 байт) в функцию, ожидающую указатель на `B` и всё готово: она сможет вызывать `B::w()` через второй указатель на *vtable* и иметь доступ к члену `b` через указатели, которые мы передаём тем же способом, что и передавали бы любой указатель на `B` .

Заметим, что эта "корректировка указателя" должна применяться так же и для вызываемых методов. Класс `C` наследует `B::w()` в таком случае. Когда `w()` вызывается через указатель на `C`, указатель (который становится указателем на `this` внутри `w()`) должен быть откорректирован. Это часто называется *регулировкой указателей*.

В некоторых случаях компилятор сгенерит переход для исправления адреса. Рассмотрим тот же код, что и выше, но на этот раз `C` перезаписывает функцию `w()`. являющуюся членом `B`:

    class A {
    public:
      int a;
      virtual void v();
    };
    
    class B {
    public:
      int b;
      virtual void w();
    };
    
    class C : public A, public B {
    public:
      int c;
      void w();
    };
    
Теперь построение объектов типа `C` выглядит следующим образом:

                               +-----------------------+
                               |     0 (top_offset)    |
                               +-----------------------+
    c --> +----------+         | ptr to typeinfo for C |
          |  vtable  |-------> +-----------------------+
          +----------+         |         A::v()        |
          |     a    |         +-----------------------+
          +----------+         |         C::w()        |
          |  vtable  |---+     +-----------------------+
          +----------+   |     |    -8 (top_offset)    |
          |     b    |   |     +----------
    1000
    -------------+
          +----------+   |     | ptr to typeinfo for C |
          |     c    |   +---> +-----------------------+
          +----------+         |    thunk to C::w()    |
                               +-----------------------+

Теперь при вызове `w()` из объекта класса `C` через указатель на `B`, вызывается переход. Что это значит? Давайте продизассемблируем это (здесь при помощи gdb):

    0x0804860c <_ZThn8_N1C1wEv+0>:  addl   $0xfffffff8,0x4(%esp)
    0x08048611 <_ZThn8_N1C1wEv+5>:  jmp    0x804853c <_ZN1C1wEv>

Итак, это просто регулирует указатель `this` и переходит к `C::w()`. Всё хорошо.

Но не значит ли вышесказанное что vtable `B` всегда указывает на `C::w()`? Я подразумеваю, что если у нас есть указатель на `B`, который на самом деле указывает на объект класса `B` (а не `C`), нам не нужно применять переход, правильно?

Правильно. Вышеприведённая встроенная таблица для `B` в `C` специальна(?) для случая `B`-в-`C`. Штатная таблица `B` нормальная и указывает напрямую в `B::w()`.

## Ромбовидное наследование: Множественные копии базовых классов (невиртуальное наследование)

Хорошо. Теперь рассмотрим действительно сложный случай. Вспомним обычную проблему нескольких копий базового класса при построении ромбовидного наследования:

    class A {
    public:
      int a;
      virtual void v();
    };
    
    class B : public A {
    public:
      int b;
      virtual void w();
    };
    
    class C : public A {
    public:
      int c;
      virtual void x();
    };
    
    class D : public B, public C {
    public:
      int d;
      virtual void y();
    };

Заметим, что `D` наследуется из `B` и `C`, а `B` и `C` оба наследуются из `A`. Это означает что `D` имеет две копии A внутри себя. Построение объекта и виртуальной встраивание таблицы такие, как мы ожидаем исходя из предыдущей секции:

                               +-----------------------+
                               |     0 (top_offset)    |
                               +-----------------------+
    d --> +----------+         | ptr to typeinfo for D |
          |  vtable  |-------> +-----------------------+
          +----------+         |         A::v()        |
          |     a    |         +-----------------------+
          +----------+         |         B::w()        |
          |     b    |         +-----------------------+
          +----------+         |         D::y()        |
          |  vtable  |---+     +-----------------------+
          +----------+   |     |   -12 (top_offset)    |
          |     a    |   |     +-----------------------+
          +----------+   |     | ptr to typeinfo for D |
          |     c    |   +---> +-----------------------+
          +----------+         |         A::v()        |
          |     d    |         +-----------------------+
          +----------+         |         C::x()        |
                               +-----------------------+

Конечно, мы ожидаем что данные `A` (член `a`) должны повторяться дважды в объекте типа `D` (и так оно и есть), и мы ожидаем что виртуальные член-функции `A` будут представлены дважды в *vtable* (и `A::v()` на самом деле там). Хорошо, здесь ничего нового.

## Ромбовидное наследование: Единичные копии виртуальных базовых классов


Но что если мы решили применить _виртуальное_ наследование? Виртуальное наследование C++ похволяет нам уточнять ромбовидную иерархию, просто гарантируя только одну копию виртуально отнаследованной базы. Давайте запишем наш код следующим образом:

    class A {
    public:
      int a;
      virtual void v();
    };
    
    class B : public virtual A {
    public:
      int b;
      virtual void w();
    };
    
    class C : public virtual A {
    public:
      int c;
      virtual void x();
    };
    
    class D : public B, public C {
    public:
      int d;
      virtual void y();
    };

Всё внезапно становится _гораздо_ сложнее. Если мы можем иметь только одну копию `A` в нашем представлении `D`, то мы более не можем использовать "фокус" со встраиванием `C` в `D` (и встраивания *vtable* части `C`, относящейся к `D` в виртуальной таблице `D`). Но как мы можем обработать обычную подмену типов если мы не можем этого сделать?

Давайте попробуем нарисовать построение:

                                       +-----------------------+
                                       |   20 (vbase_offset)   |
                                       +-----------------------+
                                       |     0 (top_offset)    |
                                       +-----------------------+
                                       | ptr to typeinfo for D |
                          +----------> +-----------------------+
    d --> +----------+    |            |         B::w()        |
          |  vtable  |----+            +-----------------------+
          +----------+                 |         D::y()        |
          |     b    |                 +-----------------------+
          +----------+                 |   12 (vbase_offset)   |
          |  vtable  |---------+       +-----------------------+
          +----------+         |       |    -8 (top_offset)    |
          |     c    |         |       +-----------------------+
          +----------+         |       | ptr to typeinfo for D |
          |     d    |         +-----> +-----------------------+
          +----------+                 |         C::x()        |
          |  vtable  |----+            +-----------------------+
          +----------+    |            |    0 (vbase_offset)   |
          |     a    |    |            +-----------------------+
          +----------+    |            |   -20 (top_offset)    |
                          |            +-----------------------+
                          |            | ptr to typeinfo for D |
                          +----------> +-----------------------+
                                       |         A::v()        |
                                       +-----------------------+

Хорошо, теперь мы видим, что `A` теперь встроено в `D` в ровно тем же способом, что и другие базовые классы. Но оно встроено в `D` а не в его непосредственные родительские классы.

## Конструкторы/Деструкторы при множественном наследовании

Как ложится в память вышеприведённый объект во время создания? И как мы убеждаемся что конструктор может безопасно работать с частично созданным объектом (и его виртуальной таблицей).

К счастью всё это происходит очень аккуратно. Пусть мы создаём новый объект типа `D` (например `new D`). Сначала память для объекта аллоцируется в куче и нам возвращается указатель. Вызывается конструктор `D`, но перед выполнением специфичных для `D` вещей, вызывается конструктор `A` (разумеется после подготовки указателя `this`). Конструктор `A` заполняет часть объекта `D`, принадлежащую объекту `A` так, как если бы она и в самом деле была объектом `A`.

    d --> +----------+
          |          |
          +----------+
          |          |
          +----------+
          |          |
          +----------+
          |          |       +-----------------------+
          +----------+       |     0 (top_offset)    |
          |          |       +-----------------------+
          +----------+       | ptr to typeinfo for A |
          |  vtable  |-----> +-----------------------+
          +----------+       |         A::v()        |
          |    a     |       +-----------------------+
          +----------+

Управление возвращается конструктору `D`, который вызывает конструктор `B` (Корректировка указателя в данном случае не нужна). Когда конструктор `B` завершается, объект выглядит как-то так:

                                                 B-in-D
                              +-----------------------+
                  
    1000
                |   20 (vbase_offset)   |
                              +-----------------------+
                              |     0 (top_offset)    |
                              +-----------------------+
    d --> +----------+        | ptr to typeinfo for B |
          |  vtable  |------> +-----------------------+
          +----------+        |         B::w()        |
          |    b     |        +-----------------------+
          +----------+        |    0 (vbase_offset)   |
          |          |        +-----------------------+
          +----------+        |   -20 (top_offset)    |
          |          |        +-----------------------+
          +----------+        | ptr to typeinfo for B |
          |          |   +--> +-----------------------+
          +----------+   |    |         A::v()        |
          |  vtable  |---+    +-----------------------+
          +----------+
          |    a     |
          +----------+

__Но стойте... Конструктор `B` изменил часть объекта, принадлежащую `A` изменив указатель на vtable!__ Как он различает `B`-в-`D` и `B`-в-чём-нибудь-ещё (или просто объекта типа `B`, что тоже важно)? Легко. Таблица виртуальных таблиц сказала ему об этом. Это структура с аббривеатурой _VTT_ является таблицей виртуальных таблиц, использующаяся во время работы конструктора. В нашем случае _VTT_ выглядит следующим образом:

       B-in-D
                                                   +-----------------------+
                                                   |   20 (vbase_offset)   |
                VTT for D                          +-----------------------+
    +-------------------+                          |     0 (top_offset)    |
    |    vtable for D   |-------------+            +-----------------------+
    +-------------------+             |            | ptr to typeinfo for B |
    | vtable for B-in-D |-------------|----------> +-----------------------+
    +-------------------+             |            |         B::w()        |
    | vtable for B-in-D |-------------|--------+   +-----------------------+
    +-------------------+             |        |   |    0 (vbase_offset)   |
    | vtable for C-in-D |-------------|-----+  |   +-----------------------+
    +-------------------+             |     |  |   |   -20 (top_offset)    |
    | vtable for C-in-D |-------------|--+  |  |   +-----------------------+
    +-------------------+             |  |  |  |   | ptr to typeinfo for B |
    |    vtable for D   |----------+  |  |  |  +-> +-----------------------+
    +-------------------+          |  |  |  |      |         A::v()        |
    |    vtable for D   |-------+  |  |  |  |      +-----------------------+
    +-------------------+       |  |  |  |  |
                                |  |  |  |  |                         C-in-D
                                |  |  |  |  |      +-----------------------+
                                |  |  |  |  |      |   12 (vbase_offset)   |
                                |  |  |  |  |      +-----------------------+
                                |  |  |  |  |      |     0 (top_offset)    |
                                |  |  |  |  |      +-----------------------+
                                |  |  |  |  |      | ptr to typeinfo for C |
                                |  |  |  |  +----> +-----------------------+
                                |  |  |  |         |         C::x()        |
                                |  |  |  |         +-----------------------+
                                |  |  |  |         |    0 (vbase_offset)   |
                                |  |  |  |         +-----------------------+
                                |  |  |  |         |   -12 (top_offset)    |
                                |  |  |  |         +-----------------------+
                                |  |  |  |         | ptr to typeinfo for C |
                                |  |  |  +--
    1000
    -----> +-----------------------+
                                |  |  |            |         A::v()        |
                                |  |  |            +-----------------------+
                                |  |  |
                                |  |  |                                    D
                                |  |  |            +-----------------------+
                                |  |  |            |   20 (vbase_offset)   |
                                |  |  |            +-----------------------+
                                |  |  |            |     0 (top_offset)    |
                                |  |  |            +-----------------------+
                                |  |  |            | ptr to typeinfo for D |
                                |  |  +----------> +-----------------------+
                                |  |               |         B::w()        |
                                |  |               +-----------------------+
                                |  |               |         D::y()        |
                                |  |               +-----------------------+
                                |  |               |   12 (vbase_offset)   |
                                |  |               +-----------------------+
                                |  |               |    -8 (top_offset)    |
                                |  |               +-----------------------+
                                |  |               | ptr to typeinfo for D |
                                +----------------> +-----------------------+
                                   |               |         C::x()        |
                                   |               +-----------------------+
                                   |               |    0 (vbase_offset)   |
                                   |               +-----------------------+
                                   |               |   -20 (top_offset)    |
                                   |               +-----------------------+
                                   |               | ptr to typeinfo for D |
                                   +-------------> +-----------------------+
                                                   |         A::v()        |
                                                   +-----------------------+

Конструктор `D` переходит по указателю в *VTT* класса `D` в конструктор класса `B` (в этом случае он переходит по адресу записи **`B`-в-`D`**). И действительно, *vtable*, использующийся для разметки вышеприведённого объекта специфичен только для построения `B`-в-`D`.

Контроль возвращается в конструктор `D` и вызывается конструктор `C` (с адресом, взятым из *VTT*, указывающим на запись с адресом **`C`-в-`D` + 12**). Когда конструктор `C` завершается, объект выглядит следующим образом:

                B-in-D
                                                            +-----------------------+
                                                            |   20 (vbase_offset)   |
                                                            +-----------------------+
                                                            |     0 (top_offset)    |
                                                            +-----------------------+
                                                            | ptr to typeinfo for B |
                        +---------------------------------> +-----------------------+
                        |                                   |         B::w()        |
                        |                                   +-----------------------+
                        |                          C-in-D   |    0 (vbase_offset)   |
                        |       +-----------------------+   +-----------------------+
    d --> +----------+  |       |   12 (vbase_offset)   |   |   -20 (top_offset)    |
          |  vtable  |
    1000
    --+       +-----------------------+   +-----------------------+
          +----------+          |     0 (top_offset)    |   | ptr to typeinfo for B |
          |    b     |          +-----------------------+   +-----------------------+
          +----------+          | ptr to typeinfo for C |   |         A::v()        |
          |  vtable  |--------> +-----------------------+   +-----------------------+
          +----------+          |         C::x()        |
          |    c     |          +-----------------------+
          +----------+          |    0 (vbase_offset)   |
          |          |          +-----------------------+
          +----------+          |   -12 (top_offset)    |
          |  vtable  |--+       +-----------------------+
          +----------+  |       | ptr to typeinfo for C |
          |    a     |  +-----> +-----------------------+
          +----------+          |         A::v()        |
                                +-----------------------+

Как можно видеть, конструктор `C` ещё раз изменил встроенный в `A` указатель на *vtable*. Встроенные объекты `A` и `C` теперь используют специализированную для **`C`-в-`D`** виртуальную таблицу, а встроенный объект `B` использует специализированную для **`B`-в-`D`** *vtable*. Наконец создание `D` завершается, и мы заканчиваем с такой же диаграмой как и раньше:

                                       +-----------------------+
                                       |   20 (vbase_offset)   |
                                       +-----------------------+
                                       |     0 (top_offset)    |
                                       +-----------------------+
                                       | ptr to typeinfo for D |
                          +----------> +-----------------------+
    d --> +----------+    |            |         B::w()        |
          |  vtable  |----+            +-----------------------+
          +----------+                 |         D::y()        |
          |     b    |                 +-----------------------+
          +----------+                 |   12 (vbase_offset)   |
          |  vtable  |---------+       +-----------------------+
          +----------+         |       |    -8 (top_offset)    |
          |     c    |         |       +-----------------------+
          +----------+         |       | ptr to typeinfo for D |
          |     d    |         +-----> +-----------------------+
          +----------+                 |         C::x()        |
          |  vtable  |----+            +-----------------------+
          +----------+    |            |    0 (vbase_offset)   |
          |     a    |    |            +-----------------------+
          +----------+    |            |   -20 (top_offset)    |
                          |            +-----------------------+
                          |            | ptr to typeinfo for D |
                          +----------> +-----------------------+
                                       |         A::v()        |
                                       +-----------------------+


