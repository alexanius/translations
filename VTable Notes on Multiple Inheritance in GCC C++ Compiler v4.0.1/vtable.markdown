# Заметки про таблицы виртуальных функций во время множественного наследования в компиляторе GCC C++-4.0.1

## Основы. Простое наследование

Как мы обсуждали в аудитории, простое наследование приводит к построению объекта с данными базового класса, располагающимися перед данными класса-наследника. Итак, если классы `A` и `B` определены таким образом:

    class A {
    public:
      int a;
    };
    
    class B : public A {
    public:
      int b;
    };

то объекты типа `B` будут располагаться в памяти примерно так (где `b` является указателем на соответствующий объект):

    b --> +-----------+
          |     x     |
          +-----------+
          |     y     |
          +-----------+

Если у вас есть виртуальные методы:

    class A {
    public:
      int a;
      virtual void v();
    };
    
    class B : public A {
    public:
      int b;
    };

то вы получаете ещё и виртуальную таблицу:

                               +-----------------------+
                               |     0 (top_offset)    |
                               +-----------------------+
    b --> +----------+         | ptr to typeinfo for B |
          |  vtable  |-------> +-----------------------+
          +----------+         |         A::v()        |
          |     x    |         +-----------------------+
          +----------+
          |     y    
    1000
    |
          +----------+

такую, что `top_offset` и указатель на `typeinfo` находятся поверх того места, куда ведут указатели на *vtable*.

## Простое множественное наследование

Теперь рассмотрим множественное наследование:

    class A {
    public:
      int a;
      virtual void v();
    };
    
    class B {
    public:
      int b;
      virtual void w();
    };
    
    class C : public A, public B {
    public:
      int c;
    };

В этом случае объекты типа `C` имеют следующее построение:

                               +-----------------------+
                               |     0 (top_offset)    |
                               +-----------------------+
    c --> +----------+         | ptr to typeinfo for C |
          |  vtable  |-------> +-----------------------+
          +----------+         |         A::v()        |
          |     a    |         +-----------------------+
          +----------+         |    -8 (top_offset)    |
          |  vtable  |---+     +-----------------------+
          +----------+   |     | ptr to typeinfo for C |
          |     b    |   +---> +-----------------------+
          +----------+         |         B::w()        |
          |     c    |         +-----------------------+
          +----------+

...*но почему*? Почему две виртуальные таблицы находятся в одной? Что ж, подумаем о подстановке типов. Если у меня есть указатель на `C`, я могу передать его в функцию, которая ожидает указатель на `A` или в функцию, ожидающую указатель на `B`. Если функция ожидает указатель на `A` и я хочу передать ей значение моей переменной `c` (являющейся указателем на `C`), у меня уже всё готово. Вызов `A::v()` может быть сделан через (первую) *vtable*, а вызываемая функция имеет доступ к члену `a` через указатель, который я передаю таким же образом как и *любой* указатель на `A`.

Тем не менее, если я передаю значение моей переменной с указателем `c` в функцию, которая ожидает указатель на `B`, нам *так же* нужен вложенный объект типа `B` в `C` чтобы на него ссылаться. Поэтому у нас есть второй указатель на *vtable*. Мы можем передать значение указателя (`c` + 8 байт) в функцию, ожидающую указатель на `B` и всё готово: она сможет вызывать `B::w()` через второй указатель на *vtable* и иметь доступ к члену `b` через указатели, которые мы передаём тем же способом, что и передавали бы любой указатель на `B` .

Заметим, такая "корректировка указателя" должна применяться так же и для вызываемых методов. В таком случае класс `C` наследует `B::w()`. Когда `w()` вызывается через указатель на `C`, указатель (который становится указателем на `this` внутри `w()`) должен быть откорректирован. Это часто называется *регулировкой указателей*.

В некоторых случаях компилятор сгенерит переход для исправления адреса. Рассмотрим тот же код, что и выше, но на этот раз `C` перезаписывает функцию `w()`. являющуюся членом `B`:

    class A {
    public:
      int a;
      virtual void v();
    };
    
    class B {
    public:
      int b;
      virtual void w();
    };
    
    class C : public A, public B {
    public:
      int c;
      void w();
    };

Теперь построение объектов типа `C` выглядит следующим образом:

                               +-----------------------+
                               |     0 (top_offset)    |
                               +-----------------------+
    c --> +----------+         | ptr to typeinfo for C |
          |  vtable  |-------> +-----------------------+
          +----------+         |         A::v()        |
          |     a    |         +-----------------------+
          +----------+         |         C::w()        |
          |  vtable  |---+     +-----------------------+
          +----------+   |     |    -8 (top_offset)    |
          |     b    |   |     +----------
    1000
    -------------+
          +----------+   |     | ptr to typeinfo for C |
          |     c    |   +---> +-----------------------+
          +----------+         |    thunk to C::w()    |
                               +-----------------------+

Теперь при вызове `w()` из объекта класса `C` через указатель на `B`, вызывается переход. Что это значит? Давайте продизассемблируем это (здесь при помощи gdb):

    0x0804860c <_ZThn8_N1C1wEv+0>:  addl   $0xfffffff8,0x4(%esp)
    0x08048611 <_ZThn8_N1C1wEv+5>:  jmp    0x804853c <_ZN1C1wEv>

Итак, здесь просто регулируется указатель `this` и из него мы переходим к `C::w()`. Всё хорошо.

Но не значит ли вышесказанное что *vtable* `B` всегда указывает на `C::w()`? Я подразумеваю, что если у нас есть указатель на `B`, который на самом деле указывает на объект класса `B` (а не `C`), нам не нужно применять переход, не так ли?

Так. Вышеприведённая встроенная таблица для `B` в `C` сделана специально для случая `B`-в-`C`. Штатная таблица `B` нормальная и указывает напрямую в `B::w()`.

## Ромбовидное наследование: Множественные копии базовых классов (невиртуальное наследование)

Хорошо. Теперь рассмотрим действительно сложный случай. Вспомним обычную проблему нескольких копий базового класса при построении ромбовидного наследования:

    class A {
    public:
      int a;
      virtual void v();
    };
    
    class B : public A {
    public:
      int b;
      virtual void w();
    };
    
    class C : public A {
    public:
      int c;
      virtual void x();
    };
    
    class D : public B, public C {
    public:
      int d;
      virtual void y();
    };

Заметим, что `D` наследуется из `B` и `C`, а `B` и `C` оба наследуются из `A`. Это означает что `D` имеет две копии `A` внутри себя. Построение объекта и виртуальной встраивание таблицы такие, как мы ожидаем исходя из предыдущей секции:

                               +-----------------------+
                               |     0 (top_offset)    |
                               +-----------------------+
    d --> +----------+         | ptr to typeinfo for D |
          |  vtable  |-------> +-----------------------+
          +----------+         |         A::v()        |
          |     a    |         +-----------------------+
          +----------+         |         B::w()        |
          |     b    |         +-----------------------+
          +----------+         |         D::y()        |
          |  vtable  |---+     +-----------------------+
          +----------+   |     |   -12 (top_offset)    |
          |     a    |   |     +-----------------------+
          +----------+   |     | ptr to typeinfo for D |
          |     c    |   +---> +-----------------------+
          +----------+         |         A::v()        |
          |     d    |         +-----------------------+
          +----------+         |         C::x()        |
                               +-----------------------+

Конечно, мы ожидаем что данные `A` (член `a`) должны повторяться дважды в объекте типа `D` (и так оно и есть), и мы ожидаем что виртуальные член-функции `A` будут представлены дважды в *vtable* (и `A::v()` на самом деле там). Хорошо, здесь ничего нового.

## Ромбовидное наследование: Единичные копии виртуальных базовых классов


Но что если мы решили применить _виртуальное_ наследование? Виртуальное наследование C++ позволяет нам уточнять ромбовидную иерархию, просто гарантируя только одну копию виртуально отнаследованной базы. Давайте запишем наш код следующим образом:

    class A {
    public:
      int a;
      virtual void v();
    };
    
    class B : public virtual A {
    public:
      int b;
      virtual void w();
    };
    
    class C : public virtual A {
    public:
      int c;
      virtual void x();
    };
    
    class D : public B, public C {
    public:
      int d;
      virtual void y();
    };

Всё внезапно становится _гораздо_ сложнее. Если мы можем иметь только одну копию `A` в нашем представлении `D`, то мы более не можем использовать "фокус" со встраиванием `C` в `D` (и встраивания *vtable* части `C`, относящейся к `D` в виртуальной таблице `D`). Но как мы можем обработать обычную подстановку типов если мы не можем этого сделать?

Давайте попробуем нарисовать построение:

                                       +-----------------------+
                                       |   20 (vbase_offset)   |
                                       +-----------------------+
                                       |     0 (top_offset)    |
                                       +-----------------------+
                                       | ptr to typeinfo for D |
                          +----------> +-----------------------+
    d --> +----------+    |            |         B::w()        |
          |  vtable  |----+            +-----------------------+
          +----------+                 |         D::y()        |
          |     b    |                 +-----------------------+
          +----------+                 |   12 (vbase_offset)   |
          |  vtable  |---------+       +-----------------------+
          +----------+         |       |    -8 (top_offset)    |
          |     c    |         |       +-----------------------+
          +----------+         |       | ptr to typeinfo for D |
          |     d    |         +-----> +-----------------------+
          +----------+                 |         C::x()        |
          |  vtable  |----+            +-----------------------+
          +----------+    |            |    0 (vbase_offset)   |
          |     a    |    |            +-----------------------+
          +----------+    |            |   -20 (top_offset)    |
                          |            +-----------------------+
                          |            | ptr to typeinfo for D |
                          +----------> +-----------------------+
                                       |         A::v()        |
                                       +-----------------------+

Хорошо. Итак, мы видим, что `A` теперь встроено в `D` в ровно тем же способом, что и другие базовые классы. Но оно встроено в `D` а не в его непосредственные родительские классы.

## Конструкторы/Деструкторы при множественном наследовании

Как ложится в память вышеприведённый объект во время создания? И как мы убеждаемся что конструктор может безопасно работать с частично созданным объектом (и его виртуальной таблицей).

К счастью всё это происходит очень аккуратно. Пусть мы создаём новый объект типа `D` (например `new D`). Сначала память для объекта аллоцируется в куче и нам возвращается указатель. Вызывается конструктор `D`, но перед выполнением специфичных для `D` вещей, вызывается конструктор `A` (разумеется после подготовки указателя `this`). Конструктор `A` заполняет часть объекта `D`, принадлежащую объекту `A` так, как если бы она и в самом деле была объектом `A`.

    d --> +----------+
          |          |
          +----------+
          |          |
          +----------+
          |          |
          +----------+
          |          |       +-----------------------+
          +----------+       |     0 (top_offset)    |
          |          |       +-----------------------+
          +----------+       | ptr to typeinfo for A |
          |  vtable  |-----> +-----------------------+
          +----------+       |         A::v()        |
          |    a     |       +-----------------------+
          +----------+

Управление возвращается конструктору `D`, который вызывает конструктор `B` (Корректировка указателя в данном случае не нужна). Когда конструктор `B` завершается, объект выглядит как-то так:

                                                 B-in-D
                              +-----------------------+
                  
    1000
                |   20 (vbase_offset)   |
                              +-----------------------+
                              |     0 (top_offset)    |
                              +-----------------------+
    d --> +----------+        | ptr to typeinfo for B |
          |  vtable  |------> +-----------------------+
          +----------+        |         B::w()        |
          |    b     |        +-----------------------+
          +----------+        |    0 (vbase_offset)   |
          |          |        +-----------------------+
          +----------+        |   -20 (top_offset)    |
          |          |        +-----------------------+
          +----------+        | ptr to typeinfo for B |
          |          |   +--> +-----------------------+
          +----------+   |    |         A::v()        |
          |  vtable  |---+    +-----------------------+
          +----------+
          |    a     |
          +----------+

**Но стойте... Конструктор `B` изменил часть объекта, принадлежащую `A` изменив указатель на vtable!** Как он различает `B`-в-`D` и `B`-в-чём-нибудь-ещё (или просто объекта типа `B`, что тоже важно)? Легко. Таблица таблиц виртуальных функций сказала ему об этом. Это структура с аббревиатурой _VTT_ является таблицей таблиц виртуальных функций, использующаяся во время работы конструктора. В нашем случае _VTT_ выглядит следующим образом:

       B-in-D
                                                   +-----------------------+
                                                   |   20 (vbase_offset)   |
                VTT for D                          +-----------------------+
    +-------------------+                          |     0 (top_offset)    |
    |    vtable for D   |-------------+            +-----------------------+
    +-------------------+             |            | ptr to typeinfo for B |
    | vtable for B-in-D |-------------|----------> +-----------------------+
    +-------------------+             |            |         B::w()        |
    | vtable for B-in-D |-------------|--------+   +-----------------------+
    +-------------------+             |        |   |    0 (vbase_offset)   |
    | vtable for C-in-D |-------------|-----+  |   +-----------------------+
    +-------------------+             |     |  |   |   -20 (top_offset)    |
    | vtable for C-in-D |-------------|--+  |  |   +-----------------------+
    +-------------------+             |  |  |  |   | ptr to typeinfo for B |
    |    vtable for D   |----------+  |  |  |  +-> +-----------------------+
    +-------------------+          |  |  |  |      |         A::v()        |
    |    vtable for D   |-------+  |  |  |  |      +-----------------------+
    +-------------------+       |  |  |  |  |
                                |  |  |  |  |                         C-in-D
                                |  |  |  |  |      +-----------------------+
                                |  |  |  |  |      |   12 (vbase_offset)   |
                                |  |  |  |  |      +-----------------------+
                                |  |  |  |  |      |     0 (top_offset)    |
                                |  |  |  |  |      +-----------------------+
                                |  |  |  |  |      | ptr to typeinfo for C |
                                |  |  |  |  +----> +-----------------------+
                                |  |  |  |         |         C::x()        |
                                |  |  |  |         +-----------------------+
                                |  |  |  |         |    0 (vbase_offset)   |
                                |  |  |  |         +-----------------------+
                                |  |  |  |         |   -12 (top_offset)    |
                                |  |  |  |         +-----------------------+
                                |  |  |  |         | ptr to typeinfo for C |
                                |  |  |  +--
    1000
    -----> +-----------------------+
                                |  |  |            |         A::v()        |
                                |  |  |            +-----------------------+
                                |  |  |
                                |  |  |                                    D
                                |  |  |            +-----------------------+
                                |  |  |            |   20 (vbase_offset)   |
                                |  |  |            +-----------------------+
                                |  |  |            |     0 (top_offset)    |
                                |  |  |            +-----------------------+
                                |  |  |            | ptr to typeinfo for D |
                                |  |  +----------> +-----------------------+
                                |  |               |         B::w()        |
                                |  |               +-----------------------+
                                |  |               |         D::y()        |
                                |  |               +-----------------------+
                                |  |               |   12 (vbase_offset)   |
                                |  |               +-----------------------+
                                |  |               |    -8 (top_offset)    |
                                |  |               +-----------------------+
                                |  |               | ptr to typeinfo for D |
                                +----------------> +-----------------------+
                                   |               |         C::x()        |
                                   |               +-----------------------+
                                   |               |    0 (vbase_offset)   |
                                   |               +-----------------------+
                                   |               |   -20 (top_offset)    |
                                   |               +-----------------------+
                                   |               | ptr to typeinfo for D |
                                   +-------------> +-----------------------+
                                                   |         A::v()        |
                                                   +-----------------------+

Конструктор `D` переходит по указателю в *VTT* класса `D` в конструктор класса `B` (в этом случае он переходит по адресу записи `B`-в-`D`). И действительно, *vtable*, использующийся для разметки вышеприведённого объекта специфичен только для построения `B`-в-`D`.

Контроль возвращается в конструктор `D` и вызывается конструктор `C` (с адресом, взятым из *VTT*, указывающим на запись с адресом `C`-в-`D` + 12). Когда конструктор `C` завершается, объект выглядит следующим образом:

                B-in-D
                                                            +-----------------------+
                                                            |   20 (vbase_offset)   |
                                                            +-----------------------+
                                                            |     0 (top_offset)    |
                                                            +-----------------------+
                                                            | ptr to typeinfo for B |
                        +---------------------------------> +-----------------------+
                        |                                   |         B::w()        |
                        |                                   +-----------------------+
                        |                          C-in-D   |    0 (vbase_offset)   |
                        |       +-----------------------+   +-----------------------+
    d --> +----------+  |       |   12 (vbase_offset)   |   |   -20 (top_offset)    |
          |  vtable  |
    1000
    --+       +-----------------------+   +-----------------------+
          +----------+          |     0 (top_offset)    |   | ptr to typeinfo for B |
          |    b     |          +-----------------------+   +-----------------------+
          +----------+          | ptr to typeinfo for C |   |         A::v()        |
          |  vtable  |--------> +-----------------------+   +-----------------------+
          +----------+          |         C::x()        |
          |    c     |          +-----------------------+
          +----------+          |    0 (vbase_offset)   |
          |          |          +-----------------------+
          +----------+          |   -12 (top_offset)    |
          |  vtable  |--+       +-----------------------+
          +----------+  |       | ptr to typeinfo for C |
          |    a     |  +-----> +-----------------------+
          +----------+          |         A::v()        |
                                +-----------------------+

Как можно видеть, конструктор `C` ещё раз изменил встроенный в `A` указатель на *vtable*. Встроенные объекты `A` и `C` теперь используют специализированную для `C`-в-`D` виртуальную таблицу, а встроенный объект `B` использует специализированную для `B`-в-`D` *vtable*. Наконец создание `D` завершается, и мы заканчиваем с такой же диаграммой как и раньше:

                                       +-----------------------+
                                       |   20 (vbase_offset)   |
                                       +-----------------------+
                                       |     0 (top_offset)    |
                                       +-----------------------+
                                       | ptr to typeinfo for D |
                          +----------> +-----------------------+
    d --> +----------+    |            |         B::w()        |
          |  vtable  |----+            +-----------------------+
          +----------+                 |         D::y()        |
          |     b    |                 +-----------------------+
          +----------+                 |   12 (vbase_offset)   |
          |  vtable  |---------+       +-----------------------+
          +----------+         |       |    -8 (top_offset)    |
          |     c    |         |       +-----------------------+
          +----------+         |       | ptr to typeinfo for D |
          |     d    |         +-----> +-----------------------+
          +----------+                 |         C::x()        |
          |  vtable  |----+            +-----------------------+
          +----------+    |            |    0 (vbase_offset)   |
          |     a    |    |            +-----------------------+
          +----------+    |            |   -20 (top_offset)    |
                          |            +-----------------------+
                          |            | ptr to typeinfo for D |
                          +----------> +-----------------------+
                                       |         A::v()        |
                                       +-----------------------+

Уничтожение происхожит в том же ключе, только в обратном порядке. Вызываются деструкторы `D`. Далее запускается пользовательский код уничтожения, дестуруктор вызывает деструктор `C` и выдаёт ему на использование соответствующую часть *VTT* класса `D`. Деструктор `C` действует с указателями на *vtable* также как и конструктор; так что соответствующие указатели на на *vtable* сейчас указывают на таблицу `C`-в-`D`. Далее запускается пользовательский код уничтожения `C`, и управление возвращается в деструктор `D`, который далее вызывает деструктор `B` со ссылкой в *VTT* класса `D`. Деструктор `B` заставляет соотвествующие части объекта ссылаться на таблицу виртуальных функций `B`-в-`D`. Он запускает пользовательский код уничтожениея `B` и возвращает управление в деструктор `D`, который наконец вызывает деструктор `A`. Деструктор `A` меняет указатель на *vtable* и заставляет его ссылаться на *vtable* класса `A`. Наконец управление возвращается в деструктор `D` и 1000-ый деструктор объекта завершает свою работу. Память, использовавшаяся объектом возвращается системе.

Сейчас по факту всё немного сложнее. Вы видели спецификаторы "in-charge" и "not-in-charge" конструкторов и деструкторов в в предупреждениях и сообщениях об ошибках GCC или в бинарниках, выдаваемых GCC?  Что ж, дело в том, что возможны две реализации конструктора более трёх реализаций деструктора.

Конструктор со спецификатором "in-charge" (он же конструктор полного объекта) создаёт виртуальные базовые объекты, а конструктор со спецификацией "not-in-charge" (он же конструктор базового объекта) не создаёт. Рассмотрим вышеприведённый пример. Если `B` создалось, его конструктор нуждается в вызове конструктора `A` для его создания. Тем не менее если `B` и `C` создались как часть `D`, их конструкторы **не должны** создавать `A` потому что `A` - виртуальный базовый объект, и конструктор `D` позаботится о создании его как части объекта класса `D`. Рассмотрим следующие случаи:

 * Если вы делаете `new A`, "in-charge" конструктор `A` вызывается для создания `A`.
 * Когда вы делаете `new B`, вызывается "in-charge" конструктор `B`. Он вызовет "not-in-charge" конструктор `B`
 * `new C` аналогичен `new B`
 * `new D` вызывает "in-charge" конструктор `D`. Мы уже прошлись по этому примеру. "in-charge" конструктор `D` вызывает "not-in-charge" конструкторы `A`, `B` и `C` (в таком порядке).

"in-charge" деструктор аналогичен "in-charge" конструктору - он берёт заботу об уничтожению виртуальных базовых объектов. Аналогично создаётся "not-in-charge" деструктор. Но есть ещё и третий. "in-charge deleting" деструктор, который *деаллоцирует* хранилище в порядке уничтожения объекта. Итак, когда отдаётся предпочтение какому-либо из них?

Что ж, есть два вида объектов, которые могут быть уничтожены - расположенные на стеке и расположенные в куче. Рассмотрим следующий код (с ромбовидной иерархией и виртуальным наследованием, приведённым выше):

    D d;            // выделяет память для D на стеке и создаёт его
    D *pd = new D;  // выделяет память для D в куче и создаёт его
    /* ... */
    delete pd;      // вызывает "in-charge deleting" деструктор для D
    return;         // вызывает "in-charge" деструктор для лежащего на стеке D

Мы видим, что фактически операторы `delete` вызываются не кодом выполненяющим удаление, а "in-charge deleting" деструктором удаляемого объекта. Почему сделано именно так? Почему не вызвать сначала "in-charge" деструктор, а затем удалить объект? Тогда было бы только две копии реализации деструкторов, а не три...

Что ж, компилятор мог бы сделать так, но это было бы сложнее по другим причинам. Рассмотрим следующий код (подразумевая виртуальный деструктор, ведь вы всегда его используете, правда? ... *правда?!?*):

    D *pd = new D;  // выделяет память для a D в куче и создаёт его
    C *pc = d;      // у нас есть указатель на C, который указывает на D, выделенный в куче
    /* ... */
    delete pc;      // вызов деструктора через переход по виртуальной таблице, но что с удалением?

Если бы у вас не было "in-charge deleting" варианта деструктора `D`, то операции удаления пришлось бы обрабатывать указатель так же как обрабатывается деструктор. Помните, что объект `C` встроен в `D` и что наш указатель на `C` указывает в середину объекта `D`. Мы не можем просто удалить этот указатель т.к. это не тот указатель, который выдаёт функция `malloc()` во время создания объекта.

Итак, если бы у нас не было "in-charge deleting" деструктора, нам бы пришлось делать обработку оператора `delete` (и отображать это в таблицах виртуальных функций), или что-то в этом роде.

## Приведения, виртуальные и не виртуальные

Эта секция пока не написана

## Множественное наследование с виртуальными методами только с одной стороны

Хорошо. Последнее упражнение. Что если у нас есть иерархия с ромбовидным наследованием, такая же как и раньше, но виртуальные методы есть только с одной стороны? Например:

    class A {
    public:
      int a;
    };
    
    class B : public virtual A {
    public:
      int b;
      virtual void w();
    };
    
    class C : public virtual A {
    public:
      int c;
    };
    
    class D : public B, public C {
    public:
      int d;
      virtual void y();
    };

В этом случае построение объекта следующее:

                                       +-----------------------+
                                       |   20 (vbase_offset)   |
                                       +-----------------------+
                                       |     0 (top_offset)    |
                                       +-----------------------+
                                       | ptr to typeinfo for D |
                          +----------> +-----------------------+
    d --> +----------+    |            |         B::w()        |
          |  vtable  |----+            +-----------------------+
          +----------+                 |         D::y()        |
          |     b    |                 +-----------------------+
          +----------+                 |   12 (vbase_offset)   |
          |  vtable  |---------+       +-----------------------+
          +----------+         |       |    -8 (top_offset)    |
          |     c    |         |       +-----------------------+
          +----------+         |       | ptr to typeinfo for D |
          |     d    |         +-----> +-----------------------+
          +----------+
          |     a    |
          +----------+

Как можно видеть вложенный объект `C`, не имеющий виртуальных методов всё ещё имеет *vtable* (хоть и пустую). В самом деле, *все* объекты класса `C` имеют пустую таблицу виртуальных функций.
