# Заметки про виртуальные таблицы во время множественного наследования в компиляторе GCC C++-4.0.1

## Основы. Простое наследование

Как мы обсуждали в классе, простое наследование приводит к построению объекта с данными базового класса, располагающимися перед данными класса-наследника. Итак, если классы `A` и `B` опеделены таким образом:

    class A {
    public:
      int a;
    };
    
    class B : public A {
    public:
      int b;
    };

то объекты типа `B` будут располагаться в памяти примерно так (где `b` является указателем на соответствующий объект):

    b --> +-----------+
          |     x     |
          +-----------+
          |     y     |
          +-----------+

Если у вас есть виртуальные методы:

    class A {
    public:
      int a;
      virtual void v();
    };
    
    class B : public A {
    public:
      int b;
    };

то вы получаете ещё и виртуальную таблицу:

                               +-----------------------+
                               |     0 (top_offset)    |
                               +-----------------------+
    b --> +----------+         | ptr to typeinfo for B |
          |  vtable  |-------> +-----------------------+
          +----------+         |         A::v()        |
          |     x    |         +-----------------------+
          +----------+
          |     y    
    1000
    |
          +----------+

такую, что `top_offset` и указатель на `typeinfo` находятся поверх того места, куда ведут указатели на *vtable*.

## Простое множественное наследование

Теперь рассмотрим множественное наследование:

    class A {
    public:
      int a;
      virtual void v();
    };
    
    class B {
    public:
      int b;
      virtual void w();
    };
    
    class C : public A, public B {
    public:
      int c;
    };

В этом случае объекты типа `C` имеют следующее построение:

                               +-----------------------+
                               |     0 (top_offset)    |
                               +-----------------------+
    c --> +----------+         | ptr to typeinfo for C |
          |  vtable  |-------> +-----------------------+
          +----------+         |         A::v()        |
          |     a    |         +-----------------------+
          +----------+         |    -8 (top_offset)    |
          |  vtable  |---+     +-----------------------+
          +----------+   |     | ptr to typeinfo for C |
          |     b    |   +---> +-----------------------+
          +----------+         |         B::w()        |
          |     c    |         +-----------------------+
          +----------+

...*но почему*? Почему две виртуальные таблицы в одной? Что ж, подумаем о подмене типов. Если у меня есть указатель на `C`, я могу передать его в функцию, которая ожидает указатель на `A` или в функцию, ожидающую уазатель на `B`. Если функция ожидает указатель на `A` и я хочу передать ей значение моей переменной `c` (являющейся указателем на `C`), у меня уже всё готово. Вызов `A::v()` может быть сделан через (первую) *vtable*, а вызываемая функция имеет доступ к члену `a` через указатель, который я передаю таким же образом как и *любой* указатель на `A`.

Тем не менее, если я передаю значение моей переменной с указателем `c` в функцию, которая ожидает указатель на `B`, нам *так же* нужен вложенный объект типа `B` в `C` чтобы на него ссылаться. Поэтому у нас есть второй указатель на *vtable*. Мы можем передать значение указателя (`c` + 8 байт) в функцию, ожидающую указатель на `B` и всё готово: она сможет вызывать `B::w()` через второй указатель на *vtable* и иметь доступ к члену `b` через указатели, которые мы передаём тем же способом, что и передавали бы любой указатель на `B` .

Заметим, что эта "корректировка указателя" должна применяться так же и для вызываемых методов. Класс `C` наследует `B::w()` в таком случае. Когда `w()` вызывается через указатель на `C`, указатель (который становится указателем на `this` внутри `w()`) должен быть откорректирован. Это часто называется *регулировкой указателей*.

В некоторых случаях компилятор сгенерит переход для исправления адреса. Рассмотрим тот же код, что и выше, но на этот раз `C` перезаписывает функцию `w()`. являющуюся членом `B`:

    class A {
    public:
      int a;
      virtual void v();
    };
    
    class B {
    public:
      int b;
      virtual void w();
    };
    
    class C : public A, public B {
    public:
      int c;
      void w();
    };
    
Теперь построение объектов типа `C` выглядит следующим образом:

                               +-----------------------+
                               |     0 (top_offset)    |
                               +-----------------------+
    c --> +----------+         | ptr to typeinfo for C |
          |  vtable  |-------> +-----------------------+
          +----------+         |         A::v()        |
          |     a    |         +-----------------------+
          +----------+         |         C::w()        |
          |  vtable  |---+     +-----------------------+
          +----------+   |     |    -8 (top_offset)    |
          |     b    |   |     +----------
    1000
    -------------+
          +----------+   |     | ptr to typeinfo for C |
          |     c    |   +---> +-----------------------+
          +----------+         |    thunk to C::w()    |
                               +-----------------------+

Теперь при вызове `w()` из объекта класса `C` через указатель на `B`, вызывается переход. Что это значит? Давайте продизассемблируем это (здесь при помощи gdb):

    0x0804860c <_ZThn8_N1C1wEv+0>:  addl   $0xfffffff8,0x4(%esp)
    0x08048611 <_ZThn8_N1C1wEv+5>:  jmp    0x804853c <_ZN1C1wEv>

Итак, это просто регулирует указатель `this` и переходит к `C::w()`. Всё хорошо.

Но не значит ли вышесказанное что vtable `B` всегда указывает на `C::w()`? Я подразумеваю, что если у нас есть указатель на `B`, который на самом деле указывает на объект класса `B` (а не `C`), нам не нужно применять переход, правильно?

Правильно. Вышеприведённая встроенная таблица для `B` в `C` специальна(?) для случая `B`-в-`C`. Штатная таблица `B` нормальная и указывает напрямую в `B::w()`.
