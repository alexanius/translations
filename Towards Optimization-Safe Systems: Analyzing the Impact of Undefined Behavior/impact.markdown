# К созданю безопасных для оптимизации систем: анализ последствий неопределённого поведения

Xi Wang, Nickolai Zeldovich, M. Frans Kaashoek, MIT CSAIL and Armando Solar-Lezama

## Обзор

Настоящая работа посвящена изучению формирующемуся классу программных ошибок, называемым оптимизационно-неустойчивым кодом: кодом, который неожиданно  удаляется компилятором во время оптимизации из-за состояния неопределённого  поведения в программе. Нестабильный код присутствует во многих системах, включая ядро Linux и базу данных Postgres. Послдствия от нестабильного кода могут варьироваться от неправильного функционирования программ до исчезновения проверок безопасности. Для обсуждения нестабильного кода в работе представлена новая модель, определяющая нестабильный с точки зрения оптимизаций код, ведущий к неопределённому поведению. Используя эту модель м представим новый статический анализатор Stack, который точно определяет нестабильный код. Приманяя Stack к шароко используемым системам было выявлено 160 новых ошибок, которые были подтверждены и исправлены разработчиками.

## Введение

Спецификации многих языков программирования обозначают некоторые фрагменты кода как обладающие неопределённым поведением [15: §2.3], разрешая компилятору создавать команды, с произвольным поведением в таких случаях. Например в C "использование непортируемых или ошибчных программных конструкций" приводит к неопределённому поведению [24: §3.4.3].

Один из способов, который компиляторы используют при работе с неопределённым поведением - оптимизировать программы, предполагая что программа никогда не попадает в состояние неопределённого поведения. Последствя таких оптимизаций особенно удивительны для многих программистов: код, работающий при выключенных оптимизациях (т.е. при `-O0`) работает неправильно с высокими уровнями оптимизацияй (т.е. от `-O2`) т.к. компилятор считает часть кода мёртвой и удаляет её. Мы называем такой код оптимизационно-неустойчивым, или кортоко нестабильным кодом. Если удалённый код использовался для проверок безопасности, соптимизированные системы будут уязвимы для атак.

Эта статья представляет первый систематический подход для рассуждения о нестабильном коде и его определения. Мы реализовали этот подход в статическом анализаторе, называемом Stack и использовали его с целью показать наличие нестабильного кода в большом количестве программных комплексов, включая ядро Linux и базу данных Postgres. По нашим оценкам Нестабильный код присутствует в 40% из 8575 пакетов Debian Wheezy, содержащих код на C/C++. Мы также показали что чем больше копиляторы использовали в своих целях неопределённое поведение, тем к более уязвимым системам приводил нестабильный код.

    char *buf = ...;
    char *buf_end = ...;
    unsigned int len = ...;
    if (buf + len >= buf_end)
        return; /* len too large */
    if (buf + len < buf)
        return; /* overflow, buf+len wrapped around */
    /* write to buf[0..len-1] */

Рисунок 1: Проверка на переполнение указателя, найденная в нескольких кодовых базах. Код становится уязвимым после того как gcc оптимизирует второй условный оператор [13].

Для того чтобы понять что такое нестабильный код, рассмотрим проверку на переполнение указателя на рис. 1, где `buf` - указатель, а `len` - целое положительное число. Замычел программиста был в том чтобы отловить случай когда `len` что `buf + len` переполняется и обходит первую проверку на рис. 1. Мы нашли подобные проверки в нескольких системах, включая браузер Chromium [7], ядро Linux [49] и интерпритатор Python [37].

Хотя эта проверка работает с прямой адресацией, она проваливается на сегментированных архитектурах [23:§6.3.2.3]. Поэтому в стандарте C закреплено что переполненный указатель неопределён [24:§6.5.6/p8], что позволяет gcc предполагать что указатель определён всегда для любой архитектуры. Исходя из этого предположения `buf + len` должны быть больше чем buf и эта проверока на "переполнение" всегда будет давать ложный результат. Следовательно gcc удаляет проверку, открывая путь для атаки на систему [13].

    struct tun_struct *tun = ...;
    struct sock *sk = tun->sk;
    if (!tun)
        return POLLERR;
    /* write to address based on tun */

Рисунок 2: Уязвимость разменования нулевого указателя (CVE-2009-1897) в ядре Linux, где разыменование указателя `tun` стоит перед проверкой на ноль. Код становитя уязвимым т.к. gcc удаляет проверку на ноль [10].

В дополнеие к представленю новых уязвимостей, нестабильный код может усиливать уже имеющиеся уязвимостив системе. Рис. 2 показывает незначительную ошибку в ядре Linux, где программист некорректно расположил разыменование `tun->sk` перед проверкой на нулевой указатель `!tun`. Обычно ядро запрещяет доступ по нулевому указателю; нулевой `tun`, указывающий на нулевую страницу вызовет ошибку ядра при выполнении `tun->sk`, что уничтожит вызвавший её процесс. Даже если доступ к нулевой странице получен (например через mmap или другими способами [25, 45]), проверка `!tun` определит нулевой `tun` и предотвратит использование последующих уязвимостей. в обоих случаях атакующий не должен пройти проверку на нулевой указатель.

К сожалению, нестабильный код может превратить такую простую ошибку в реальную уязвимость. Например, когда gcc впервые видит разыменование `tun->sk`, он делает вывод что указатель должен быть ненулевым, т.к. стандарт C говорит что разыменование нулевого указателя неопределено [24:§6.5.3]. Т.к. `tun` ненулевой, gcc считает что проверка на ноль необязательна и удаляет её, создавая уязвимость повышения прав, которой не должно быть без оптимизации [10].

Основным препятствием при обсуждении поведения систем является плохое понимание нестабильного кода. Компиляторы, которые удаляют нестабильный код выглядят для программистов "непонятными" и "бессмысленными" [46], особенно gcc с его "творческим подходом к базовой семантике C" [27]. С другой стороны разработчики компиляторов придерживаются аргументации что стандарт C разрешает подобные оптимизации, чем пользуются многоие компиляторы (см. §2.3); т.к. это "некорректный код" [17], который программисты должны исправить.

Кто прав в этом споре? С точки зрения компилятора, программисты сделали ошибку в коде. Например рис. 2 очвидно содержит ошибку, и даже на рис. 1 возможен некореектный код при строгой интерпритации стандарта C. Тем не менее эти ошибки довольно тонкие, и их понимание требует глубокого знания спецификации языка. Поэтому неудивительно что такие ошибки продолжают распространяться.
