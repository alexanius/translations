# К созданию безопасных для оптимизации систем: анализ последствий неопределённого поведения

Xi Wang, Nickolai Zeldovich, M. Frans Kaashoek и Armando Solar-Lezama

MIT CSAIL 

Copyright is held by the owner/author(s).
SOSP’13, Nov. 3–6, 2013, Farmington, Pennsylvania, USA.
ACM 978-1-4503-2388-8/13/11.
http://dx.doi.org/10.1145/2517349.2522728

От переводчика:

В работе часто применяется термин "well-defined". Т.к. дословный перевод выглядит неорганично, в некоторых случаях он переводится как "стабильный".

## Обзор

Настоящая работа посвящена изучению формирующегося класса программных ошибок под названием оптимизационно-неустойчивый код. Это код, который неожиданно удаляется компилятором во время оптимизации из-за состояния неопределённого  поведения в программе. Нестабильный код присутствует во многих системах, включая ядро Linux и базу данных Postgres. Последствия от нестабильного кода могут варьироваться от неправильного функционирования программ до исчезновения проверок безопасности. Для обсуждения нестабильного кода в работе представлена новая модель, дающая определение нестабильному с точки зрения оптимизаций коду, ведущему к неопределённому поведению. Используя эту модель мы представим новый статический анализатор Stack, который точно определяет нестабильный код. Применяя Stack к широко используемым системам было выявлено 160 новых ошибок, которые были подтверждены и исправлены разработчиками.

## Введение

В спецификациях многих языков программирования присутствует описание некоторых фрагментов кода, обладающих неопределённым поведением  [15: §2.3], что разрешает компилятору создавать команды, с произвольным поведением. Например в C "использование непортируемых или ошибочных программных конструкций" приводит к неопределённому поведению [24: §3.4.3].

Один из способов, используемых компиляторами при работе с неопределённым поведением - оптимизировать программы, предполагая что программа никогда не попадает в состояние неопределённого поведения. Последствия таких оптимизаций бывают особенно удивительными для многих программистов: код, работающий правильно при выключенных оптимизациях (т.е. при `-O0`) работает неправильно с высокими уровнями оптимизаций (т.е. от `-O2`), т.к. компилятор считает участки кода мёртвыми и удаляет их. Мы называем такой код оптимизационно-неустойчивым, или коротко нестабильным кодом. Если удалённый код использовался для проверок безопасности, соптимизированные системы будут уязвимы для атак.

Эта статья представляет первый систематический подход для определения и исследования нестабильного кода. Мы реализовали этот подход в статическом анализаторе, называемом Stack и использовали его с целью показать наличие нестабильного кода в большом количестве программных комплексов, включая ядро Linux и базу данных Postgres. По нашим оценкам нестабильный код присутствует в 40% из 8575 пакетов Debian Wheezy, содержащих код на C/C++. Мы также показали что чем больше компиляторы использовали в своих целях неопределённое поведение, тем к более уязвимым системам приводил нестабильный код.

    char *buf = ...;
    char *buf_end = ...;
    unsigned int len = ...;
    if (buf + len >= buf_end)
        return; /* len too large */
    if (buf + len < buf)
        return; /* overflow, buf+len wrapped around */
    /* write to buf[0..len-1] */

Рисунок 1: Проверка на переполнение указателя, найденная в нескольких кодовых базах. Код становится уязвимым после того как gcc оптимизирует второй условный оператор [13].

Для того чтобы понять что такое нестабильный код, рассмотрим проверку на переполнение указателя на рис. 1, где `buf` - указатель, а `len` - целое положительное число. Программист хотел отловить случай когда `len` на столько велико, что `buf + len` переполняется и проходит первую проверку на рис. 1. Мы нашли подобные проверки в нескольких системах, включая браузер Chromium [7], ядро Linux [49] и интерпретатор Python [37].

Хотя эта проверка работает с прямой адресацией, она проваливается на сегментированных архитектурах [23: §6.3.2.3]. Поэтому в стандарте C закреплено что переполненный указатель неопределён [24: §6.5.6/p8], что позволяет gcc предполагать что указатель определён всегда для любой архитектуры. Исходя из этого предположения `buf + len` должны быть больше чем buf, и эта проверка на "переполнение" всегда будет давать ложный результат. Следовательно gcc удаляет проверку, делая систему уязвимой для атак [13].

    struct tun_struct *tun = ...;
    struct sock *sk = tun->sk;
    if (!tun)
        return POLLERR;
    /* write to address based on tun */

Рисунок 2: Уязвимость разыменования нулевого указателя (CVE-2009-1897) в ядре Linux, где разыменование указателя `tun` стоит перед проверкой на ноль. Код становится уязвимым т.к. gcc удаляет проверку на ноль [10].

В дополнение к созданию новых уязвимостей, нестабильный код может усиливать уже имеющиеся уязвимости в системе. Рис. 2 показывает незначительную ошибку в ядре Linux, где программист некорректно расположил разыменование `tun->sk` перед проверкой на нулевой указатель `!tun`. Обычно ядро запрещает доступ по нулевому указателю; нулевой `tun`, указывающий на нулевую страницу вызовет ошибку ядра при выполнении `tun->sk`, что уничтожит вызвавший её процесс. Даже если доступ к нулевой странице получен (например через mmap или другими способами [25, 45]), проверка `!tun` определит нулевой `tun` и предотвратит использование последующих уязвимостей. В обоих случаях атакующий не должен пройти проверку на нулевой указатель.

К сожалению, нестабильный код может превратить такую простую ошибку в реальную уязвимость. Например, когда gcc впервые видит разыменование `tun->sk`, он делает вывод что указатель должен быть ненулевым, т.к. стандарт C говорит что разыменование нулевого указателя неопределено [24: §6.5.3]. Т.к. `tun` ненулевой, gcc считает что проверка на ноль необязательна и удаляет её, создавая уязвимость повышения прав, которой не должно быть без оптимизации [10].

Основным препятствием при обсуждении поведения систем является плохое понимание нестабильного кода. Компиляторы, которые удаляют нестабильный код выглядят для программистов "непонятными" и "бессмысленными" [46], особенно gcc с его "творческим подходом к базовой семантике C" [27]. С другой стороны разработчики компиляторов придерживаются аргументации что стандарт C разрешает подобные оптимизации, чем пользуются многие компиляторы (см. §2.3); т.к. это "некорректный код" [17], который программисты должны исправить.

Кто прав в этом споре? С точки зрения компилятора, программисты сделали ошибку в коде. Например рис. 2 очевидно содержит ошибку, и даже на рис. 1 возможен некорректный код при строгой интерпретации стандарта C. Тем не менее, эти ошибки довольно тонкие, и их понимание требует глубокого знания спецификации языка. Поэтому неудивительно что такие ошибки продолжают распространяться.

С точки зрения программиста компиляторы проводят оптимизацию слишком агрессивно. Тем не менее оптимизации важны для достижения хорошей производительности; многие оптимизации закладываются на точную семантику языка C, такую как удаление ненужных проверок на ноль или оптимизацию целочисленных переменных в цикле [20, 29]. Таким образом разработчикам компиляторов сложно отказаться от сложных и правомерных оптимизаций, что приводит к искажению мыслей программиста  [29: §3].

Данная работа помогает разрешить этот спор вводя модель идентификации нестабильного кода, которая позволяет компилятору выдавать предупреждения при удалении кода, основанного на неопределённом поведении. Модель точно определяет условия при которых фрагмент кода может иметь неопределённое поведение. Используя эти условия мы можем определить участки, которые могут быть удалены в предположении что неопределённое поведение никогда не случается; особенно какой либо участок, достижимый только при входных данных, вызывающих неопределённое поведение в нестабильном коде. Мы делаем эту модель более точной в §3.

Анализатор Stack реализует эту модель для выявления нестабильного кода. Например на рис. 2 он выдаёт предупреждение что проверка указателя на ноль `!tun` нестабильна из-за предшествующего разыменования `tun->sk`. Stack сначала вычисляет условия неопределённого поведения для широкого спектра конструкций, включая указатели, целочисленную арифметику, доступы к памяти и вызовы библиотечных функций. После этого он использует решатель [3] для определения мест в которых код может быть удалён из-за неопределённого поведения при условии, например, если код достижим только если условие, вызывающее неопределённое поведение выполняется. Мы надеемся, что Stack поможет программистам найти нестабильный код в их приложениях, и что наша модель поможет компиляторам лучше определять случаи в которых оптимизация может быть небезопасна, и когда компилятор должен выдавать предупреждение.

Мы реализовали анализатор Stack используя компилятор LLVM [30] и решатель Boolector [3]. Применяя его к широкому спектру систем мы выявили 160 новых ошибок, которые были подтверждены и исправлены разработчиками. Мы также получили положительные отзывы от внешних пользователей, которые с помощью Stack исправили дополнительные ошибки как в открытых, так и в коммерческих системах. Наш опыт показывает, что нестабильный код - широко распространённая угроза в системах, что злоумышленник может использовать уязвимости, вызванные работой основных компиляторов с нестабильным кодом, и что Stack полезен для выявления нестабильного кода.

Основные результаты данной работы:

* новая модель для понимания нестабильного кода
* статический анализатор для выявления нестабильного кода, и
* детальное изучение нестабильного кода в реальных системах

Другой вывод из данной работы состоит в том, что разработчики языка должны быть осторожны, разрешая различным конструкциям языка иметь неопределённое поведение. Почти любой язык разрешает разработчику писать программы с неопределённым значением, прописанным в спецификации языка. Наш опыт с C/C++ показывает что неосторожное обращение с неопределённостями может приводить к неотлавливаемым ошибкам.

Оставшаяся часть работы организована следующим образом. §2 рассказывает про базовые определения. В §3 представлена наша модель нестабильного кода. §4 описывает дизайн Stack. §5 даёт краткое описание его реализации. В §6 рассказано про на опыт применения Stack для выявления нестабильного кода и оценивает работу анализатора. В §7 приведены схожие работы. В §8 находятся выводы.

## Основы

В этом разделе представлены основы неопределённого поведения, и как оно может приводить к нестабильному коду. Они основаны на ранних исследованиях [26, 41, 49] и постах в блогах [29, 39, 40] которые описывают примеры нестабильного кода и дополняют их эволюцией оптимизаций в компиляторе.

||Конструкция| Достаточное условие | Неопределённое пофедение         |
|-----------|-----------|---------------------|----------------------------------|
|Язык       | p + x     | p\_∞ + x\_∞ [0, 2^n− 1] | переполнение указателя           |
|| *p        | p = NULL            | разыменование нулевого указателя |
|| x op\_s y  | x\_∞ op\_s y\_∞ [−2^{n−1} , 2^{n−1} − 1] | переполнение занового целочисленного |
|| x / y, x % y | y = 0 | деление на ноль |
|| x << y, x >> y | y < 0 ∨ y ≥ n | переполнение сдвигом |
|| a[x] | x < 0 ∨ x ≥ ARRAY_SIZE(a) | переполнение буфера |
|Библиотека | `abs(x)` | x = −2^{n−1} | Переполнение абсолютного значения |
|| `memcpy(dst, src, len)` | abs(dst − src) < len | переполнение при копировании памяти |
|| использование q после free(p) | alias(p, q) | использование после удаления |
|| использование q после p′ = `realloc(p, ...)` | alias(p, q) ∧ p′ != NULL | использование после `relloc`|

Рисунок 3: Список достаточных (но не необходимых) условий для неопределённого поведения в известных конструкциях языка C [24: §J.2]. Здесь __p, p', q__ - n-битные указатели; __x, y__ - n-битные целые; _a_ - массив, размер которого обозначается `ARRAY_SIZE(a)`; __op_s__ является бинарным оператором __+, -, *, /, %__ над знаковыми целыми; __x∞___ означает что _x_ имеет бесконечный диапазон значений; __NULL__ - нулевой указатель; __alias( p, q)__ означает что _a_ и _p_ указывают на один и тотже объект.

### Неопределённое поведение

Рис. 3 показывает список конструкций и условия при которых их поведение не определено по стандарту [24: §J.2]. Один из типов неопределённого поведения - простые ошибки программирования, такие как разыменование нулевого указателя, переполнение буфера и использование после удаления. Другой тип - непортируемые конструкции, аппаратные реализации которых всегда имеют небольшие различия.

Например, когда происходит переполнение знакового целого или деление на ноль, на x86 инструкция деления ловится [22: §3.2], в то время как на PowerPC она тихо выдаёт некорректный результат [21: §3.3.8]. Другой пример - инструкции сдвига: левый сдвиг 32-ого бита на 32 бита возвращает 0 на ARM и PowerPC, но 1 на x86; однако левый сдвиг 32-ого бита на 64 бита возвращает 0 на ARM, но 1 на x86 и PowerPC. Исследование Wang'а [49] содержит больше информации про подобные архитектурные различия.

Для разработки более портируемых систем, стандарт языка мог бы навязать универсальное поведение для ошибочных или непортируемых конструкций, как это сделано во многих высокоуровневых языках. Если бы это было так, компилятору пришлось бы создавать дополнительные инструкции. Например для создания чётко определённого обработчика ошибок (т.е. исключений времени исполнения) на случай переполнения буфера, компилятору понадобится вставить дополнительные проверки границ для операций доступа в память. Аналогично для создания последовательной проверки операции сдвига на x86 для каждого `x << y` компилятору будет необходимо вставлять проверку рядом с `y` (пока не будет доказано что `y` не переполняется) как например:

    if (y < 0 ∨ y ≥ n) then 0 else x << y.

Семейство C-подобных языков использует другой подход. Специализируясь на системном программировании, их спецификации доверяют программистам [23: §0] и считают, что их код никогда не приводит к неопределённому поведению. Такое предположение даёт больше свободы компилятору чем высказывание что результат операции архитектурно зависим. Пока такое предположение позволяет компилятору создавать эффективный код без лишних проверок, оно оставляет открытую дверь для нестабильного кода.

### Примеры нестабильного кода

Верхняя строка рис. 4 показывает шесть типичных примеров нестабильного кода под видом разумных проверок. Все эти проверки могут быть сведены компилятором к тождественно ложным, и при работе оптимизаций стать мёртвым кодом, даже если ни одна из них напрямую не вызывает неопределённого поведения. Мы воспользуемся этими примерами для проверки существующих компиляторов в §2.3.

Проверка `p + 100 < p` похожа на представленную в рис. 1, которая не выполняется из-за предположения о невозможности переполнения указателя.

Проверка нулевого указателя `!p` с более ранним разыменованием взята из рис. 2, в котором она не выполняется из-за предположения о невозможности разыменования нулевого указателя.

Проверка `x + 100 < x` со знаковым целым `x` не выполняется из-за предположения о невозможности целочисленного знакового переполнения. Однажды это привело к жестким дебатам между C-программистами и разработчиками gcc [17].

Другая проверка `x^+ + 100 < 0`смотрит что оптимизации выполняют более тщательную проверку, предполагая отсутствие целочисленного переполнения; `x^+` значит что `x` является положительным.

Проверка сдвига `!(1 << x)` призванная отловить большое значение `x`, взята из патча к файловой системе ext4 [31]. Она не выполняется из-за предположения о невозможности переполнения сдвигом.

Проверка `abs(x) < 0` была использована в интерпретаторе PHP для отлова наименьшего отрицательного значения (т.е. `-2^{n-1}`). Она не выполняется когда оптимизации понимают эту библиотечную функцию и предполагают отсутствие переполнения значения по модулю [18].

### Эволюция оптимизаций

Мы выбрали 12 известных C/C++ компиляторов чтобы посмотреть что они сделают с примерами нестабильного кода: два открытых компилятора (gcc и clang) и десять свежих коммерческих компиляторов (от HP, armcc от ARM, icc от Intel, msvc от Microsoft, open64 от AMD , pathcc от PathScale, suncc от Oracle, TMS320C6000 от TI, компилятор от Wind River’s Diab, and
XL C compiler от IBM’s). Для каждого примера нестабильного кода мы смотрели, преобразует ли компилятор в проверку в тождественно ложную, и если да, то находили наименьший уровень оптимизации -On на котором это происходит. Результаты показаны в таблице 4.

Далее для изучения эволюции оптимизаций, мы будем использовать gcc и clang, т.к. их история изменений легко доступна. Для gcc мы выбрали следующие версии, время выпуска которых охватывает более десятилетия:

* gcc 2.95.3, последний из 2.x, выпущен в 2001;
* gcc 3.4.6, последний из 3.x, выпущен в 2006;
* gcc 4.2.1, последняя GPLv2 версия, выпущена в 2007 и до сих пор широко используется в BSD системах;
* gcc 4.8.1, последняя версия, выпущена в 2013.

Для сравнения, мы выбрали две версии clang, 1.0 выпущенная в 2009, и последняя 3.3, выпущенная в 2013.

Мы сделали следующие наблюдения из существующих компиляторов на рис. 4. Во-первых удаление нестабильного кода - обычное явление среди компиляторов, не только в последних gcc как заявляли некоторые программисты [27]. Даже gcc 2.95.3 удаляет `x + 100 < x`. Некоторые компиляторы удаляют нестабильный код, который не удаляет gcc (напрмер clang в случае `1 << x`)

Во-вторых из разных версий gcc и clang мы видим что по мере эволюции компиляторов и появления в них новых оптимизаций удаляется всё больше нестабильного кода. Например, gcc 4.x более агрессивен в удалении нестабильного кода по сравнению с gcc 2.x, т.к. он использует новый анализ диапазонов [36].

В-третьих, удаление нестабильного кода происходит на стандартных оптимизациях, в основном на -O2, уровнем оптимизаций, используемым для релизов по умолчанию (например autoconf [32: §5.10.3]); некоторые компиляторы удаляют нестабильный код даже на самом низком уровне оптимизаций -O0. Поэтому понижение уровня оптимизаций, как это сделано в Postgres [28] - ненадёжный способ работы с нестабильным кодом.

В-четвёртых, оптимизации используют неопределённое поведение не только самого языка, но также и библиотечных функций (например `abs` [18] и `realloc` [40]) т.к. со временем компиляторы научились их распознавать.

Т.к. компиляторы улучшают свои оптимизации, например реализовывая новые алгоритмы (например анализ диапазонов в gcc 4.x версий) или используя неопределённое поведение в большем количестве конструкций (напрмер библиотечные функции), мы ожидаем увеличение ошибок в нестабильном коде.

## Модель нестабильного кода

Удаление нестабильного кода так как это делают компиляторы в §2 является правомерным по стандарту языка, и не является ошибкой компилятора [39: §3]. Но это непонятно программистам. Мы поставили перед собой цель выявлять такие участки кода и выдавать предупреждения по ним. Как мы увидим в §6.2, эти предупреждения часто возникают на участках кода, которые программисты хотят исправить, а не заглушить предупреждения компилятора. Эта цель требует точной модели понимания нестабильного кода для гарантий того что предупреждения будут выданы только для нестабильного кода, а не для очевидно мертвого, который может быть безопасно удалён. Этот раздел вводит модель описания нестабильного кода и представляет инструментарий с двумя алгоритмами его выявления.

### Нестабильный код

Для формализации непонимания программистами стандарта C, приводящего к нестабильному коду, давайте определим C\* как диалект C который обладает полностью определённой семантикой для участков кода, имеющих неопределённое поведение в C. Например C\* определён для прямой адресации, нулевого указателя и охватывающей семантики для целочисленной арифметики и арифметики указателей [38]. Участок кода *e* это строка или выражение в конкретном месте кода в программе *P*. Если компилятор преобразует участок *e* так что меняется поведение *P* в C\*,  но не в C, то такой участок называется нестабильным.

Пусть *P[e/e′]* - программа, полученная методом замены *e* на некоторый участок *e'* на той же позиции исходного кода. Когда компилятор имеет право заменять *P* на *P[e/e']*, что обозначается как *P -> P[e/e']*? В языке, спецификация которого не содержит непределённого поведения ответ будет простым: это правомерно для каждого случая, т.к. *P* и *P[e/e']* выдают один и тот же результат. В спецификации языка с неопределённым поведением ответ более сложный; а именно, он состоит в том, что это верно для каждого случая, в котором выполняются:

* *P* и *P[e/e']* выдают одинаковый результат без создания неопределённого поведения, или
* *P* создаёт неопределённое поведение, в котором действия *P[e/e']* не играют роли

Используя эти обозначения, ниже мы определим понятие нестабильного кода.

_Определение 1_ (Нестабильный код). Участок кода *e* в программе *P* является нестабильным по стандарту C и C\* если существует такой участок *e'* что *P -> P[e/e']* корректен в C и некорректен в C\*.

Например, на рис. 4 в соответствии со стандартом C компилятор имеет право заменить разумные проверки тождественно ложным выражением, в то время как гипотетический компилятор C\* не может сделать того же. Поэтому эти проверки также являются нестабильным кодом.

### Подход для определения нестабильного кода

Приведённое выше определение показывает сущность нестабильного кода, но не показывает способов выявления нестабильного кода, т.к. сложно рассуждать о поведении всей программы. Как агент для поиска изменений в поведении программы, Stack ищет код, который может быть преобразован некоторой оптимизацией _O_ в C, но не в C\*. В частности для этого Stack использует двух-фазовую схему:

1. Запускаем _O_ без предположения о неопределённом поведении, которое схоже с оптимизациями в C\*; и
2. запускаем _O_ ещё раз, на этот раз исходя из предположения о неопределённом поведении, которое схоже с более агрессивной оптимизацией в C.

Если _O_ на второй фазе оптимизирует дополнительный код, мы предполагаем что причина, по которой _O_ не сделал этого на первой фазе заключается  в том, что это изменило бы семантику программы в C\* и таким образом Stack заключает что этот код нестабилен.

Основанный на оптимизациях подход Stack'а в нахождении нестабильного кода упускает нестабильный код, который оптимизатор не может удалить на второй фазе из-за особенностей своей работы, даже если существует какой-то оптимизатор, который может. Этот подход также может выдавать ложные результаты если оптимизатор недостаточно агрессивен в удалении кода на первой фазе.  Таким образом одной из задач при проектировании Stack было соответствие с достаточно агрессивным оптимизатором для минимизации данной проблемы.

Для работы такого подхода Stack'у требуется оптимизатор, который может выборочно делать предположения о наличии неопределённого поведения. Для построения такого оптимизатора мы формализовали понятие "делать предположение о наличие неопределённого поведения" в §3.2.1 вводя хорошо _предположение о стабильности программы_, которое содержит допущение для языка C что программист никогда не напишет программу, приводящую к неопредлённому поведению. При работе с оптимизатором, который может принимать на вход явные допущения , Stack  может включить (или выключить) оптимизации, основанные на неопределённом поведении, сопровождая (или нет) стабильную программу допущением для оптимизатора. Мы создали два агрессивных оптимизатора, которые следуют этому допущению: один, который удаляет недостижимый код (§3.2.2) и другой, который упрощает необязательные вычисления (§3.2.3).

### Предположение о стабильности программы

Мы формализовали значение предположения о поведении компилятора следующим образом. Предположим, что программе подаётся на вход *x*. Дан участок кода _e_, пусть __R_e__(*x*) означает условия его достижимости, которые выполняются если _e_ будет выполнен при входных данных _x_; и пусть __U_e__(*x*) означает его неопределённое поведение, или коротко условие UB (undefined behaviour), которое показывает, является ли _e_ неопределённым поведением при входных данных *x* исходя из семантики C (см. рис. 3).

И __R_e__(*x*) и __U_e__(*x*) булевы выражения. Например, дано рызыменование указателя `p*` в выражении _e_. одно из условий UB __U_e__(*x*): `p = NULL` (т.е. разыменование нулевого указателя). 

Интуитивно, в стабильной программе указатель `p` не должен быть нулевым при разыменовании. Другими словами, отрицание условия UB, `p != NULL` должно выполняются всякий раз при исполнении _e_. Ниже мы обобщили этот пример.

*Определение 2* (Предположение о стабильной программе). Участок кода _e_ стабилен на входе *x* если выполнение _e_ никогда не приводит к неопределённому поведению в _e_:

    Re(x) → ¬Ue(x). (1)

Более того, программа стабильна на входных данных если каждый участок программы стабилен на входных данных, обозначенных ∆:

    ∆(x) = /\_{e∈P} Re(x) → ¬Ue(x). (2)

### Удаление недостижимого кода

Первый алгоритм выявляет нестабильный код, который может быть удалён (т.е. __P ~> P[e/∅]__, где _e_ - выражение). Например, если для достижения участка кода требуется ввести программу в неопределённое поведение, то этот участок должен быть недостижим. Мы формализовали это ниже.

**Теорема 1** (Удаление). В стабильной программе _P_, оптимизатор может удалить фрагмент кода _e_ если не существует входных данных *x*, при которых достигается _e_ и удовлетворяется допущение о стабильной программе *∆(x)*:

    ∄x : Re (x) ∧ ∆(x) (3)

Булево выражение __R_e__(*x*) ∧ ∆(*x*) называется _вопросом об удалении_.

_Доказательство_. Полагая что выполняется ∆(*x*), если вопрос об удалении __R_e__(*x*) ∧ ∆(*x*) всегда ложен, то __R_e__(*x*) должен быть ложен, что означает недостижимость _e_.

Рассмотрим рис. 2 в качестве примера. В программе входными данными является только `tun`. Для прохождения первой проверки `if` условием достижимости выражения `return` является `!tun`. Существует одно условие, вызывающее UB `tun = NULL` во время разыменования указателя `tun->sk`, которое достигается если условие выполняется. В результате вопрос об удалении __R_e__(*x*) ∧ ∆(*x*) для участка кода `return` выглядит следующим образом:

    !tun ∧ (true → ¬(tun = NULL)).

Очевидно что не существует `tun`, удовлетворяющего этому условию. Поэтому удаление выражения `return` становится возможным.

    1: procedure Eliminate(P)
    2:   for all e ∈ P do
    3:     if Re (x) is UNSAT then
    4:       Remove(e)              ▷ trivially unreachable
    5:     else
    6:       if Re(x) ∧ ∆(x) is UNSAT then
    7:         Report(e)
    8:         Remove(e)            ▷ unstable code eliminated

Рисунок 5: Алгоритм удаления. Он указывает на нестабильный код, который становится недостижимым в хорошо определённых программах.

Используя вышеприведённое определение легко составить алгоритм выявления нестабильностей, приводящих к удалению кода (см. рис. 5). Алгоритм сначала удаляет нестабильные участки без предположения о стабильности программы, а потом предупреждает об участках, ставших недостижимыми с этим предположением. Последние являются нестабильным кодом.
