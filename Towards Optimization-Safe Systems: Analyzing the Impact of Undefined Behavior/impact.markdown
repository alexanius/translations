# К созданю безопасных для оптимизации систем: анализ последствий неопределённого поведения

Xi Wang, Nickolai Zeldovich, M. Frans Kaashoek, MIT CSAIL and Armando Solar-Lezama

## Обзор

Настоящая работа посвящена изучению формирующемуся классу программных ошибок, называемым оптимизационно-неустойчивым кодом: кодом, который неожиданно  удаляется компилятором во время оптимизации из-за состояния неопределённого  поведения в программе. Нестабильный код присутствует во многих системах, включая ядро Linux и базу данных Postgres. Послдствия от нестабильного кода могут варьироваться от неправильного функционирования программ до исчезновения проверок безопасности. Для обсуждения нестабильного кода в работе представлена новая модель, определяющая нестабильный с точки зрения оптимизаций код, ведущий к неопределённому поведению. Используя эту модель м представим новый статический анализатор Stack, который точно определяет нестабильный код. Приманяя Stack к шароко используемым системам было выявлено 160 новых ошибок, которые были подтверждены и исправлены разработчиками.

## Введение

Спецификации многих языков программирования обозначают некоторые фрагменты кода как обладающие неопределённым поведением [15: §2.3], разрешая компилятору создавать команды, с произвольным поведением в таких случаях. Например в C "использование непортируемых или ошибчных программных конструкций" приводит к неопределённому поведению [24: §3.4.3].

Один из способов, который компиляторы используют при работе с неопределённым поведением - оптимизировать программы, предполагая что программа никогда не попадает в состояние неопределённого поведения. Последствя таких оптимизаций особенно удивительны для многих программистов: код, работающий при выключенных оптимизациях (т.е. при `-O0`) работает неправильно с высокими уровнями оптимизацияй (т.е. от `-O2`) т.к. компилятор считает часть кода мёртвой и удаляет её. Мы называем такой код оптимизационно-неустойчивым, или кортоко нестабильным кодом. Если удалённый код использовался для проверок безопасности, соптимизированные системы будут уязвимы для атак.

Эта статья представляет первый систематический подход для рассуждения о нестабильном коде и его определения. Мы реализовали этот подход в статическом анализаторе, называемом Stack и использовали его с целью показать наличие нестабильного кода в большом количестве программных комплексов, включая ядро Linux и базу данных Postgres. По нашим оценкам Нестабильный код присутствует в 40% из 8575 пакетов Debian Wheezy, содержащих код на C/C++. Мы также показали что чем больше копиляторы использовали в своих целях неопределённое поведение, тем к более уязвимым системам приводил нестабильный код.

    char *buf = ...;
    char *buf_end = ...;
    unsigned int len = ...;
    if (buf + len >= buf_end)
        return; /* len too large */
    if (buf + len < buf)
        return; /* overflow, buf+len wrapped around */
    /* write to buf[0..len-1] */

Рисунок 1: Проверка на переполнение указателя, найденная в нескольких кодовых базах. Код становится уязвимым после того как gcc оптимизирует второй условный оператор [13].

Для того чтобы понять что такое нестабильный код, рассмотрим проверку на переполнение указателя на рис. 1, где `buf` - указатель, а `len` - целое положительное число. Замычел программиста был в том чтобы отловить случай когда `len` что `buf + len` переполняется и обходит первую проверку на рис. 1. Мы нашли подобные проверки в нескольких системах, включая браузер Chromium [7], ядро Linux [49] и интерпритатор Python [37].

Хотя эта проверка работает с прямой адресацией, она проваливается на сегментированных архитектурах [23: §6.3.2.3]. Поэтому в стандарте C закреплено что переполненный указатель неопределён [24: §6.5.6/p8], что позволяет gcc предполагать что указатель определён всегда для любой архитектуры. Исходя из этого предположения `buf + len` должны быть больше чем buf и эта проверока на "переполнение" всегда будет давать ложный результат. Следовательно gcc удаляет проверку, открывая путь для атаки на систему [13].

    struct tun_struct *tun = ...;
    struct sock *sk = tun->sk;
    if (!tun)
        return POLLERR;
    /* write to address based on tun */

Рисунок 2: Уязвимость разменования нулевого указателя (CVE-2009-1897) в ядре Linux, где разыменование указателя `tun` стоит перед проверкой на ноль. Код становитя уязвимым т.к. gcc удаляет проверку на ноль [10].

В дополнеие к представленю новых уязвимостей, нестабильный код может усиливать уже имеющиеся уязвимостив системе. Рис. 2 показывает незначительную ошибку в ядре Linux, где программист некорректно расположил разыменование `tun->sk` перед проверкой на нулевой указатель `!tun`. Обычно ядро запрещяет доступ по нулевому указателю; нулевой `tun`, указывающий на нулевую страницу вызовет ошибку ядра при выполнении `tun->sk`, что уничтожит вызвавший её процесс. Даже если доступ к нулевой странице получен (например через mmap или другими способами [25, 45]), проверка `!tun` определит нулевой `tun` и предотвратит использование последующих уязвимостей. в обоих случаях атакующий не должен пройти проверку на нулевой указатель.

К сожалению, нестабильный код может превратить такую простую ошибку в реальную уязвимость. Например, когда gcc впервые видит разыменование `tun->sk`, он делает вывод что указатель должен быть ненулевым, т.к. стандарт C говорит что разыменование нулевого указателя неопределено [24: §6.5.3]. Т.к. `tun` ненулевой, gcc считает что проверка на ноль необязательна и удаляет её, создавая уязвимость повышения прав, которой не должно быть без оптимизации [10].

Основным препятствием при обсуждении поведения систем является плохое понимание нестабильного кода. Компиляторы, которые удаляют нестабильный код выглядят для программистов "непонятными" и "бессмысленными" [46], особенно gcc с его "творческим подходом к базовой семантике C" [27]. С другой стороны разработчики компиляторов придерживаются аргументации что стандарт C разрешает подобные оптимизации, чем пользуются многоие компиляторы (см. §2.3); т.к. это "некорректный код" [17], который программисты должны исправить.

Кто прав в этом споре? С точки зрения компилятора, программисты сделали ошибку в коде. Например рис. 2 очвидно содержит ошибку, и даже на рис. 1 возможен некореектный код при строгой интерпритации стандарта C. Тем не менее эти ошибки довольно тонкие, и их понимание требует глубокого знания спецификации языка. Поэтому неудивительно что такие ошибки продолжают распространяться.

С точки зрения программиста компиляторы проводят оптимизацию слишком агрессивно. Тем не менее оптимизации важны для достижения хорошей производительности; многие оптимизации закладываются на точную сементику языка C, такую как удаление ненужных проверок на ноль или оптимизацию целочисленных переменных в цикле [20, 29]. Таким образом для разработчиков компиляторов сложно отказаться от сложных и правомерных оптимизаций, что приводит к искажению мыслей программиста  [29: §3].

Данная работа помогает разрешить этот спор вводя модель идентификации нестабильного кода, которая позволяет компилятору выдавать предупреждения при удалении кода, основанного на неопределённом поведении. Модель точно определяет условия при которых фрагмент кода может иметь неопределённое поведение. Используя эти условия мы можем определить участки, которые могут быть удалены в предположении что неопределённое поведение никогда не случается; особенно какой либо участок, достижимый только при входных данных, вызывающих неопределённое поведение в нестабильном коде. Мы делаем эту модель более точной в §3.

Анализатор Stack реализует эту модель для выявления нестабильного кода. Например на рис. 2 он выдаёт предупреждение что проверка указателя на ноль `!tun` нестабильна из-за предшествующего разыменования `tun->sk`. Stack сначала вычисляет условия неопределённого поведения для широкого спектра конструкций, включая указатели, целочисленную арифметику, доступы к памяти и вызовы библиотечных функций. После этого он использует решатель [3] для определения мест в которых код может быть удалён из-за неопределённого поведения в условии, например если код достижим только если условие неопределённого поведения выполняется. Мы надеемся, что Stack поможет программистам найти нестабильный код в их приложениях и что наша модель поможет компиляторам лучше определять случаи в которых оптимизация может быть небезопасна, и когда компилятор должен выдавать предупреждение.

Мы реализовали анализатор Stack используя компилятор LLVM [30] и решатель Boolector [3]. Применяя его к широкому спектру систем мы выявили 160 новых ошибок, которые были подтверждены и исправлены разработчиками. Мы также получили положительные отзывы от внешних пользователей, которые с помощью Stack исправили дополнительные ошибки как в открытых, так и в коммерческих системах. Наш опыт показывает, что нестабильный код широко распространёная угроза в системах, что злоумышленник может использовать уязвимости, вызванные работой основных компиляторов с нестабильным кодом и что Stack полезен для выявления енстабильного кода.

Основные результаты данной работы:

* новая модель для понимания нестабильного кода
* статический анализатор для выявления нестабильного кода, и
* детальное изучение нестабильного кода в реальных системах

Другое заключение, которое можно сделать из данной работы это то что разработчики языка должны быть осторожны, разрешая различным конструкциям языка иметь неопределённое поведение. Почти любой язык разрешает разработчику писать программы с неопределённым значением, прописанным в спецификации языка. Наш опыт с C/C++ показывает что неосторожно обращение с неопределённостями может приводить к неотлавливаемым ошибкам.

Оставшая часть работы организована следующим образом. §2 рассказывает про базовые определения. В §3 представлена наша модель нестабильного кода. §4 описывает дизайн Stack. §5 даёт краткое описание его реализации. В §6 рассказано про на опыт применения Stack для выявления нестабильного кода и оценивает работу анализатора. В §7 приведены схожие работы. В §8 находятся выводы.

## Основы

В этом разделе представлены основы неопределённого поведения и как оно может приводить к нестабильному коду. Они основаны на ранних исследованиях [26, 41, 49] и постах в блогах [29, 39, 40] которые описывают примеры нестабильного кода и дополняют их эволюцией оптимизаций в компиляторе.

|           |Конструкция| Достаточное условие | Неопределённое пофедение         |
|-----------|-----------|---------------------|----------------------------------|
|Язык       | p + x     | p\_∞ + x\_∞ [0, 2^n− 1] | переполнение указателя           |
|| *p        | p = NULL            | разыменование нулевого указателя |
|| x op\_s y  | x\_∞ op\_s y\_∞ [−2^{n−1} , 2^{n−1} − 1] | переполнение занового целочисленного |
|| x / y, x % y | y = 0 | деление на ноль |
|| x << y, x >> y | y < 0 ∨ y ≥ n | переполнение сдвигом |
|| a[x] | x < 0 ∨ x ≥ ARRAY_SIZE(a) | переполнение буфера |
|Библиотека | `abs(x)` | x = −2^{n−1} | Переполнение абсолютного значения |
|| `memcpy(dst, src, len)` | abs(dst − src) < len | переполнение при копировании памяти |
|| использование q после free(p) | alias(p, q) | использование после удаления |
|| использование q после p′ = `realloc(p, ...)` | alias(p, q) ∧ p′ != NULL | использование после `relloc`|

Рисунок 3: Список достаточных (но не необходимых) условий для неопределённого поведения в известных конструкциях языка C [24: §J.2]. Здесь __p, p', q__ - n-битные указатели; __x, y__ - n-битные целые; _a_ - массив, размер которого обозначается `ARRAY_SIZE(a)`; __op_s__ является бинарным оператором __+, -, *, /, %__ над знаковыми целыми; __x∞___ означает что _x_ имеет бесконечный диапазон значений; __NULL__ - нулевой указатель; __alias( p, q)__ означает что _a_ и _p_ указывают на один и тотже объект.

### Неопределённое поведение

Рис. 3 показывает список конструкций и условия при которых их поведение не определено по стандарту [24: §J.2]. Один из типов неопределённого поведения - просто ошибки программирования, такие как разыменование нулевого указателя, переполнение буфера и использование после удаления. другой тип - непортируемые конструкции, аппаратные реализациикоторых всегда имеют небольшие различия.

Например, когда происходит переполнение занового целого или деление на ноль, на x86 инструкция деления ловится [22: §3.2], в то время как на PowerPC она тихо выдаёт некорректный результат [21: §3.3.8]. Другой пример - инструкции сдвига: левый сдвиг 32-ого бита на 32 бита возвращает 0 на ARM и PowerPC, но 1 на x86; однако левый сдвиг 32-ого бита на 64 бита возвращает 0 на ARM, но 1 на x86 и PowerPC. Исследование Wang'а содержит больше информации про подобные архитектурные различия.

Для разработки более портируемых систем, стандарт языка мог бы навязать ниверсальное поведение для ошибочных или непортируемых конструкций как это сделано во многих высокоуровневых языках. Если бы это было так, компилятору пришлось бы создавать дополнительные инструкции. Например для создания хорошо определённого обработчика ошибок (т.е. исключений времени исполнения) на случай переполнения буфера, компилятору понадобится вставить дополнительные проверки границ для операций доступа в память. Аналогично для создания последовательной проверки операции сдвига на x86 для каждого `x << y` компилятору будет необходимо вставлять проверку рядом с `y` (пока не будет доказано что `y` не переполняется) как например:

    if (y < 0 ∨ y ≥ n) then 0 else x << y.

Семейство C-подобных языков использует другой подход. Специализируясь на системном программировании, их спецификации доверяют программистам [23: §0] и считают, что их код никогда не приводит к неопределённому поведению. Это предположение даёт больше свободы компилятору чем высказывание что результат операции архитекторно зависим. Пока такое предположение позволяет компилятору создавать эффективный код без лишних проверок, оно оставляет открытую дверь для нестабильного кода.
