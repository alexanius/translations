<!---
% Published in:
% · Proceeding
% PASTE '07 Proceedings of the 7th ACM SIGPLAN-SIGSOFT workshop on Program 
% analysis for software tools and engineering
% Pages 43 - 48
% ACM New York, NY, USA ©2007
% table of contents ISBN: 978-1-59593-595-3 doi>10.1145/1251535.1251543
-->

# Обзор проекта Saturn

## Обзор

Мы представляем обзор системы анализа программ Saturn, включающую в себя обоснование трёх главных технических решений: использование функции за раз или обобщение анализа, использование ограничений и использование языка логического программирования для описания алгоритмов программы анализа. Мы утверждаем, что комбинация загрублений и ограничений позволяет Saturn достигать как высокой масштабируемости, так и высокой точности, в то время как использование языка логического программирования с ограничениями позволяет использовать краткие высокоуровневые выражения для анализа программ.

Categories and Subject Descriptors D.2.4 \[Software Engineering\]: Software/Program Verification; F.3.2 \[Logics and Meanings of Programs\]: Semantics of Programming Languages

General Terms Design, Experimentation, Languages

Keywords program analysis, verification, boolean satisfiability

## Вступление

Saturn --- система статического анализа программ. Saturn стремится как к масштабируемости, так и к точности, чтобы, в конечном счёте, быть в состоянии верифицировать отсутствие определённых типов ошибок в реальных системах. Saturn основан на трёх основных идеях:

* Saturn основан на обобщениях: каждая функция _f_ анализируется отдельно, вычисляя общее поведение _f_. Обобщённая может также быть прикреплена к типам, глобальным переменным и массивам.

* Saturn также основан на загрублениях: анализ выражен как система ограничений, описывающих как состояние в одной точке программы относится к состоянию в соседних точках программы. Базовый язык ограничений в Saturn основан на булевой выполнимости, где каждый бит доступен процедуре или циклу, представленным как отдельная булева переменная.

* Анализ программы в Saturn выражен в языке логического программирования с поддержкой управления ограничениями и доступа к обобщениям.

В сочетании эти идеи дают возможность Saturn кратко выражать точный анализ, в то же время обеспечивая возможность масштабирования для очень больших программ. Использование ограничений и логических программ позволяет укоротить анализы, которые упрощаются для понимания и верификации чем анализы, написанные на более низких уровнях абстракции. Побитовый чувствительный к потоку управления анализ даёт обеспечивает точность, в то время как анализ одной функции за раз и обобщение обеспечивает масштабируемость --- Saturn повседневно используется для анализа всего ядра linux (с более чем 6 млн. строк кода) и другими большими проектами с открытыми исходными кодами.

На данный момент проект Saturn преследует две связные цели. Первая - понять как программисты на практике структурируют большие системы для того чтобы изучить и описать программы так как они существуют в природе. Выбор и описание полезные структур в больших системах требует помощи автоматики (т.е. программного анализа) для классификации и систематизирования гигантского количества сырых данных (т.е. программ). Вторая цель - создать инструменты, которые смогут доказывать полезные свойства программ, либо находя ошибки, либо доказывая их отсутствие. Анализы, разработанные для Saturn нашли тысячи неизвестных ранее ошибок в широко используемых программных системах. Мы также выяснили, что определение шаблонов, которые программисты используют для структурирования кода чтобы понимать его, всегда важный шаг в проектировании удобного инструмента для поиска ошибок или верификации.

На рис. 1 можно увидеть блок-схему инструментария Saturn. Фронтэнд для C (на данный момент CIL) представляет абстрактные синтаксические деревья программы как отношения, сохраняя их в нескольких синтаксических базах данных. Далее для каждой функции в синтаксической базе данных вызывается программа анализа, написанная на Calypso - языке программирования Saturn. Программу исполняет интерпретатор Calypso, создающий ограничения и запрашивающий решатели ограничений, выдающие обобщённыу информацию и создающие отчёты об ошибках. Эти отчёты могут быть просмотрены как обычный тест, так и как основанный на XML пользовательский интерфейс, в зависимости от анализа.

Этот документ даёт краткий обзор основных компонент Saturn: использование обобщений (Секция 2), ограничений (Секция 3), язык логического программирования (Секция 4) и то как они взаимодействуют друг с другом.

## Анализ, основанный на обобщениях

Одна из определяющих характеристик Saturn - обобщённость: единица анализа --- функция, и единственный способ для функции f сослаться на результаты анализа функции g - через обобщение g. Хотя анализ, основанный на обобщениях был известен долгое время (начиная с ранних работ по пересечениям типов), он противоречит многим недавним попыткам автоматизированного анализа программ, в том числе другим проектам, в которые вовлечены члены нашей собственной группы. Поэтому стоит привести аргументы за и против обобщённого анализа.

На чисто семантическом уровне есть два привлекательных аспекта обобщённого анализа. Во-первых это, естественно, поддержка контекстной чувствительности, т.к. любой полиморфизм в общем случае легко обойти, когда обобщение обрабатывается в разных местах вызова. Во-вторых также естественно, что в Saturn можно создавать композицию обобщённых анализов, которые применимы как к открытым, так и к закрытым программам. (Открытая программа содержит свободные идентификаторы, такие как библиотеки, оторванные от программы; закрытая программа полна и может исполняться). Под композицией мы понимаем что анализ функции не делает предположений о возможной среде исполнения, в которой функция вызывается, и таким образом вызывающие функции не должны присутствовать для вычисления полезной информации о функции, которая является объектом анализа отдельной библиотеки. Другой способ - анализ всей программы, в котором создаётся представление всей программы и анализируется целиком. Некоторые анализы всей программы (например анализ мономорфных форм классов для объектно-ориентированных языков) не могут быть восприняты для композиции анализа, потому что анализ предполагает знание специфичного контекста, в котором используется каждая функция в программе. Стоит отметить, тем не менее, что множество других систем анализа всей программы (большинство из них основаны на решении систем ограничений) могут в принципе быть довольно просто адаптированы для композиционного анализа, но этого пока не сделано. По факту для создания композиционного анализа необходимо написать больше кода, чем для анализа всей программы. Как минимум необходимо спроектировать и потом реализовать полиморфные обобщения для каждой функции, и часто требует анализ дополнительных усилий для представления всех возможных окружений, в которых функция может использоваться. Хотя композиционный анализ, вероятно, наиболее естественен для Saturn, он позволяет также проводить и анализ всей программы (включая основанный на запросах межпроцедурный анализ), и на практике, по крайней мере пока, множество завершённых анализов Saturn выполнены с элементами обоих стилей.

На наш взгляд реальная польза обобщённого анализа лежит в системе инженерных преимуществ. Ограничивающий фактор для большинства систем анализа - не время, а объём: для больших программ сложно спроектировать представление, которое располагается полностью в главной памяти. Чем тратить усилия на поиск способов сжатия представления программы для уменьшения занимаемого объёма, лучше поступить также как поступают базы данных и научные приложения, сталкивающиеся с большими объёмами данных: использовать внешние алгоритмы, которые производят вычисления небольшими кусочками между диском и главной памятью. Анализ, основанный на обобщениях хорошо ложится на эту парадигму, имея в качестве единицы анализа отдельную функцию.
